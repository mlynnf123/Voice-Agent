import Fastify from 'fastify';
import WebSocket from 'ws';
import dotenv from 'dotenv';
import fastifyFormBody from '@fastify/formbody';
import fastifyWs from '@fastify/websocket';
import twilio from 'twilio';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

dotenv.config();

const {
    OPENAI_API_KEY,
    TWILIO_ACCOUNT_SID,
    TWILIO_AUTH_TOKEN,
    TWILIO_FROM_NUMBER,
    SERVER_URL,
    CALCOM_API_KEY,
} = process.env;

if (!OPENAI_API_KEY) { console.error('Missing OPENAI_API_KEY'); process.exit(1); }
if (!TWILIO_ACCOUNT_SID || !TWILIO_AUTH_TOKEN || !TWILIO_FROM_NUMBER) { console.error('Missing Twilio creds'); process.exit(1); }
if (!SERVER_URL) { console.error('Missing SERVER_URL'); process.exit(1); }
if (!CALCOM_API_KEY) { console.warn('‚ö†Ô∏è  Missing CALCOM_API_KEY ‚Äî booking tool will fail'); }

const twilioClient = twilio(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN);
const fastify = Fastify();
fastify.register(fastifyFormBody);
fastify.register(fastifyWs);

// ‚îÄ‚îÄ Config from admin dashboard ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function loadConfig() {
    try {
        const data = fs.readFileSync(path.join(__dirname, 'config.json'), 'utf-8');
        return JSON.parse(data);
    } catch {
        return { voice: 'verse', temperature: 0.8, vadThreshold: 0.8, vadSilenceDuration: 1200, systemPrompt: '' };
    }
}

function loadKnowledgeBase() {
    const knowledgeDir = path.join(__dirname, 'knowledge');
    if (!fs.existsSync(knowledgeDir)) return '';
    const files = fs.readdirSync(knowledgeDir).filter(f => f.endsWith('.txt') || f.endsWith('.md'));
    if (files.length === 0) return '';
    let content = '\n\n# Knowledge Base\n\n';
    for (const file of files) {
        const text = fs.readFileSync(path.join(knowledgeDir, file), 'utf-8');
        content += `## ${file}\n${text}\n\n`;
    }
    return content;
}

function logCall(callData) {
    const callsPath = path.join(__dirname, 'calls.json');
    let calls = [];
    try { calls = JSON.parse(fs.readFileSync(callsPath, 'utf-8')); } catch {}
    calls.unshift({ id: Date.now().toString(), timestamp: new Date().toISOString(), ...callData });
    fs.writeFileSync(callsPath, JSON.stringify(calls, null, 2));
}

const PORT = process.env.PORT || 5050;
const CALCOM_EVENT_TYPE_ID = 4522154;

const LOG_EVENT_TYPES = [
    'error', 'response.done', 'session.created', 'session.updated',
    'input_audio_buffer.speech_started', 'input_audio_buffer.speech_stopped',
    'input_audio_buffer.committed',
    'response.function_call_arguments.done',
];

const SHOW_TIMING_MATH = false;
const callVariables = new Map();

// ‚îÄ‚îÄ Cal.com Booking Tool Definition (OpenAI function calling format) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const TOOLS = [
    {
        type: 'function',
        name: 'book_meeting',
        description: 'Books a free roofing inspection appointment on the Cal.com calendar. Call this when the homeowner agrees to schedule an inspection and you have collected their name, email, preferred date/time, and timezone.',
        parameters: {
            type: 'object',
            properties: {
                attendee_name: {
                    type: 'string',
                    description: 'Full name of the person booking (e.g. "John Smith")',
                },
                attendee_email: {
                    type: 'string',
                    description: 'Email address of the person booking',
                },
                attendee_timezone: {
                    type: 'string',
                    description: 'Timezone in IANA format like "America/Chicago" or "America/New_York". Default to America/Chicago for Austin TX area.',
                },
                start_time: {
                    type: 'string',
                    description: 'Start time in ISO 8601 UTC format, e.g. "2026-02-20T15:00:00Z". Convert from the caller\'s preferred time.',
                },
            },
            required: ['attendee_name', 'attendee_email', 'start_time'],
        },
    },
];

// ‚îÄ‚îÄ Execute Cal.com booking ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function executeBookMeeting({ attendee_name, attendee_email, attendee_timezone, start_time }) {
    const tz = attendee_timezone || 'America/Chicago';
    
    const body = {
        eventTypeId: CALCOM_EVENT_TYPE_ID,
        start: start_time,
        attendee: {
            name: attendee_name,
            email: attendee_email,
            timeZone: tz,
        },
    };

    console.log('üìÖ Booking Cal.com meeting:', JSON.stringify(body, null, 2));

    try {
        const resp = await fetch('https://api.cal.com/v2/bookings', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${CALCOM_API_KEY}`,
                'cal-api-version': '2024-08-13',
            },
            body: JSON.stringify(body),
        });

        const data = await resp.json();
        console.log('üìÖ Cal.com response:', resp.status, JSON.stringify(data, null, 2));

        if (resp.ok && data.status === 'ACCEPTED') {
            return {
                success: true,
                message: `Booking confirmed! Inspection scheduled for ${start_time}. A confirmation email has been sent to ${attendee_email}.`,
                booking_id: data.data?.id || data.id,
            };
        } else {
            return {
                success: false,
                message: `Booking failed: ${data.message || data.error || JSON.stringify(data)}. Let the caller know you'll have the office follow up to schedule manually.`,
            };
        }
    } catch (err) {
        console.error('üìÖ Cal.com booking error:', err);
        return {
            success: false,
            message: `Booking system error: ${err.message}. Apologize and let them know the office will call to confirm.`,
        };
    }
}

// ‚îÄ‚îÄ System Prompt ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function buildSystemPrompt({ first_name, address }) {
    const now = new Date();
    const currentDate = now.toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', timeZone: 'America/Chicago' });
    const currentTime = now.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', timeZone: 'America/Chicago' });

    return `# Personality

You are Jamie, an outbound calling agent at J&J Roofing Pros in Austin, Texas. You're a real person on the team ‚Äî friendly, helpful, and good at your job. Never mention AI, bots, or anything like that.

# Environment

You are making outbound phone calls to businesses in the Austin, Texas area, on behalf of JJ Roofing. You're calling to inquire about their properties and assess their potential need for roofing services. You have access to company information, property data, and scheduling tools. When making the first call, Wait for the prospect to say 'Hello' or answer the phone before you start speaking. SYSTEM CONTEXT: Today's date is ${currentDate} and the current time is ${currentTime}. The caller's timezone is America/Chicago.

# Tone

Your tone is highly professional, authoritative yet consultative, and empathetic. You do not sound like a high-pressure salesperson; you sound like an elite structural diagnostician.

Sound like a real person:
- Speak at a natural pace, especially in the greeting.
- Short responses. 1-2 sentences max, then pause or ask a question.
- Use filler words naturally: "yeah," "gotcha," "for sure," "oh nice," "ah okay"
- Contractions always: "we're," "you'll," "that's," "I'll"
- Acknowledge before responding: "Oh gotcha..." "Ah, okay..." "Mm-hmm..."
- Do not interrupt the user ever, wait till they are finished speaking. Don't interrupt with filler words either.
- If there is no quick response after asking a question or saying something, please wait until the user says or replies back before you say anything again.
- NEVER repeat yourself. If you already said your greeting, do NOT say it again. Move the conversation forward naturally.
- If there's silence after you speak, wait patiently. Do NOT fill silence by repeating what you just said.

Conversation rhythm:
- Listen ‚Üí Acknowledge ‚Üí Respond briefly ‚Üí Ask a question
- Don't interrupt the user. Allow them to finish speaking before responding.
- Pause after asking something. Let them talk.

Opening:
- Start every call the same way: "Hey, this is Jamie calling from J&J Roofing. I was hoping to ask a quick question about the property at ${address}."
- Short. Friendly. Direct. Sound natural!
- Say this opening ONLY ONCE. After that, never repeat it.

# Lead Information
- Contact first name: ${first_name}
- Property address: ${address}

# Goal

Your primary goal is to qualify leads and schedule roofing inspections for J&J Roofing Pros.

1. **Initial Contact and Property Confirmation:**
   - Start the call with the standard opening.
   - Confirm you're speaking with the property owner or manager.
   - Verify the property address.

2. **Lead Qualification:**
   - Determine the current condition of the roof (age, visible issues).
   - Ask about any recent roofing work or inspections.
   - Identify the type of roof (flat, shingle, metal, etc.).
   - Gauge their interest in a free roofing inspection.
   - During the conversation, do not ask more than 3 questions.

3. **Scheduling (If Qualified):**
   - Collect all necessary information:
     - Name (first and last)
     - Phone (repeat back to confirm)
     - Address (full address with city)
     - Email (repeat back to them to confirm you have spelling correct) - this is needed for booking the appointment
     - What they need (inspection, repair, storm damage, etc.)
     - Preferred date
     - Preferred time (morning/afternoon, or specific)
     - Notes (optional ‚Äî anything else helpful)
   - Confirm the appointment details with the contact.
   - Use the book_meeting tool with the collected information.
   - If successful, confirm the appointment and explain that someone will call 30 minutes prior.
   - If unsuccessful, apologize and offer to have the office call them back.

4. **Handling Objections:**
   - "We're not interested": Politely thank them for their time and end the call.
   - "We just had our roof inspected": Ask when the inspection was and if they have any concerns. If recent and no concerns, thank them. If old or concerns, proceed with qualification.
   - "Send me some information": Offer to email information and follow up with a call.
   - "We use another roofing company": Acknowledge and ask if they're happy with their current service. If not, proceed with qualification.

5. **Answering Potential Questions (Anticipate):**
   - Who is J&J Roofing?: Briefly explain J&J Roofing Pros is a local, reputable roofing company.
   - Why are you calling?: Explain you're offering free roofing inspections to businesses who have been impacted by hail damage this year.

6. **Call to Action (Booking the Audit):** Once the prospect is qualified, transition to booking.
   - "Based on everything you've mentioned, I'd love to get you scheduled with a free inspection to start. From there we'll assess the damage and get you the best price possible. When is a good time this week for someone from our team to come by? You do not have to be there, but you can if you'd like."
   - If they agree: "What does your calendar look like for later this week?"
   - Use the book_meeting tool to lock in the appointment, confirm their best email address to send the invite, and politely end the call.`;
}

// ‚îÄ‚îÄ Routes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

fastify.get('/', async (req, reply) => {
    reply.send({ message: 'J&J Roofing Voice Agent is running!', tools: ['book_meeting'] });
});

fastify.post('/make-call', async (request, reply) => {
    const { to_number, first_name, address } = request.body || {};
    if (!to_number || !first_name || !address) {
        return reply.status(400).send({ error: 'Missing: to_number, first_name, address' });
    }
    try {
        const call = await twilioClient.calls.create({
            to: to_number,
            from: TWILIO_FROM_NUMBER,
            url: `${SERVER_URL}/outbound-call-twiml?first_name=${encodeURIComponent(first_name)}&address=${encodeURIComponent(address)}`,
            statusCallback: `${SERVER_URL}/call-status-webhook`,
            statusCallbackEvent: ['initiated', 'ringing', 'answered', 'completed'],
            statusCallbackMethod: 'POST',
        });
        console.log(`üìû Outbound call: ${call.sid} ‚Üí ${to_number}`);
        logCall({ to: to_number, firstName: first_name, address, status: 'initiated', callSid: call.sid });
        reply.send({ success: true, callSid: call.sid, to: to_number });
    } catch (err) {
        console.error('‚ùå Call failed:', err);
        reply.status(500).send({ error: err.message });
    }
});

fastify.all('/outbound-call-twiml', async (request, reply) => {
    const first_name = request.query.first_name || 'there';
    const address = request.query.address || 'your property';
    const callSid = (request.body && request.body.CallSid) || request.query.CallSid || 'unknown';
    callVariables.set(callSid, { first_name, address });

    const twimlResponse = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
    <Connect>
        <Stream url="wss://${new URL(SERVER_URL).host}/media-stream">
            <Parameter name="first_name" value="${first_name}" />
            <Parameter name="address" value="${address}" />
        </Stream>
    </Connect>
</Response>`;
    reply.type('text/xml').send(twimlResponse);
});

fastify.post('/call-status-webhook', async (request, reply) => {
    const { CallSid, CallStatus, Duration } = request.body || {};
    console.log(`üìä Status: ${CallSid} ‚Üí ${CallStatus}${Duration ? ` (${Duration}s)` : ''}`);
    reply.send({ received: true });
});

fastify.get('/call-status/:callSid', async (request, reply) => {
    try {
        const call = await twilioClient.calls(request.params.callSid).fetch();
        reply.send({ callSid: call.sid, status: call.status, to: call.to, duration: call.duration });
    } catch (err) {
        reply.status(404).send({ error: `Call not found: ${request.params.callSid}` });
    }
});

// ‚îÄ‚îÄ WebSocket media-stream ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

fastify.register(async (fastify) => {
    fastify.get('/media-stream', { websocket: true }, (connection, req) => {
        console.log('üîå Client connected to media-stream');

        let streamSid = null;
        let latestMediaTimestamp = 0;
        let lastAssistantItem = null;
        let markQueue = [];
        let responseStartTimestampTwilio = null;
        let firstName = 'there';
        let address = 'your property';

        const config = loadConfig();
        const openAiWs = new WebSocket(
            `wss://api.openai.com/v1/realtime?model=gpt-realtime&temperature=${config.temperature}`,
            { headers: { Authorization: `Bearer ${OPENAI_API_KEY}` } }
        );

        // ‚îÄ‚îÄ Initialize session with tools ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const initializeSession = () => {
            let systemPrompt = buildSystemPrompt({ first_name: firstName, address });
            const knowledgeBase = loadKnowledgeBase();
            if (knowledgeBase) systemPrompt += knowledgeBase;
            if (config.systemPrompt) systemPrompt += '\n\n# Additional Instructions\n\n' + config.systemPrompt;

            const sessionUpdate = {
                type: 'session.update',
                session: {
                    type: 'realtime',
                    model: 'gpt-realtime',
                    output_modalities: ['audio'],
                    audio: {
                        input: { format: { type: 'audio/pcmu' }, turn_detection: { type: 'server_vad', threshold: config.vadThreshold, prefix_padding_ms: 400, silence_duration_ms: config.vadSilenceDuration } },
                        output: { format: { type: 'audio/pcmu' }, voice: config.voice },
                    },
                    instructions: systemPrompt,
                    tools: TOOLS,
                    tool_choice: 'auto',
                },
            };

            console.log('ü§ñ Session configured ‚Äî waiting for caller to speak');
            openAiWs.send(JSON.stringify(sessionUpdate));
            // No manual greeting ‚Äî the system prompt tells Jamie how to greet.
            // Server VAD will detect the caller's "hello" and auto-trigger a response.
        };

        // ‚îÄ‚îÄ Handle function calls (book_meeting) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const handleFunctionCall = async (response) => {
            const callId = response.call_id;
            const fnName = response.name;
            let args;

            try {
                args = JSON.parse(response.arguments);
            } catch (e) {
                console.error('‚ùå Failed to parse function args:', response.arguments);
                args = {};
            }

            console.log(`üîß Function call: ${fnName}`, args);

            let result;
            if (fnName === 'book_meeting') {
                result = await executeBookMeeting(args);
            } else {
                result = { success: false, message: `Unknown function: ${fnName}` };
            }

            console.log(`üîß Function result:`, result);

            // Send function result back to OpenAI
            openAiWs.send(JSON.stringify({
                type: 'conversation.item.create',
                item: {
                    type: 'function_call_output',
                    call_id: callId,
                    output: JSON.stringify(result),
                },
            }));

            // Trigger AI to respond with the result
            openAiWs.send(JSON.stringify({ type: 'response.create' }));
        };

        const handleSpeechStartedEvent = () => {
            // Only interrupt if the AI has been speaking for at least 500ms
            // This prevents echo/noise from cutting off the AI mid-sentence
            if (markQueue.length > 0 && responseStartTimestampTwilio != null) {
                const elapsedTime = latestMediaTimestamp - responseStartTimestampTwilio;
                if (elapsedTime < 500) {
                    console.log(`‚è≥ Ignoring speech event ‚Äî AI only spoke ${elapsedTime}ms`);
                    return;
                }
                console.log(`üõë Interrupting AI after ${elapsedTime}ms`);
                if (lastAssistantItem) {
                    openAiWs.send(JSON.stringify({
                        type: 'conversation.item.truncate',
                        item_id: lastAssistantItem,
                        content_index: 0,
                        audio_end_ms: elapsedTime,
                    }));
                }
                connection.send(JSON.stringify({ event: 'clear', streamSid }));
                markQueue = [];
                lastAssistantItem = null;
                responseStartTimestampTwilio = null;
            }
        };

        const sendMark = () => {
            if (streamSid) {
                connection.send(JSON.stringify({
                    event: 'mark', streamSid, mark: { name: 'responsePart' },
                }));
                markQueue.push('responsePart');
            }
        };

        // ‚îÄ‚îÄ OpenAI WebSocket handlers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        openAiWs.on('open', () => {
            console.log('‚úÖ Connected to OpenAI Realtime API');
            setTimeout(initializeSession, 100);
        });

        openAiWs.on('message', (data) => {
            try {
                const response = JSON.parse(data);

                if (response.type === 'error') {
                    console.log(`‚ùå ERROR:`, JSON.stringify(response, null, 2));
                } else if (LOG_EVENT_TYPES.includes(response.type)) {
                    console.log(`üì® ${response.type}`);
                }

                // Handle audio output
                if (response.type === 'response.output_audio.delta' && response.delta) {
                    connection.send(JSON.stringify({
                        event: 'media', streamSid, media: { payload: response.delta },
                    }));
                    if (!responseStartTimestampTwilio) {
                        responseStartTimestampTwilio = latestMediaTimestamp;
                    }
                    if (response.item_id) lastAssistantItem = response.item_id;
                    sendMark();
                }

                // Handle function calls
                if (response.type === 'response.function_call_arguments.done') {
                    handleFunctionCall(response);
                }

                // Handle speech interruption
                if (response.type === 'input_audio_buffer.speech_started') {
                    handleSpeechStartedEvent();
                }
            } catch (error) {
                console.error('Error processing OpenAI message:', error);
            }
        });

        // ‚îÄ‚îÄ Twilio WebSocket handlers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        connection.on('message', (message) => {
            try {
                const data = JSON.parse(message);
                switch (data.event) {
                    case 'media':
                        latestMediaTimestamp = data.media.timestamp;
                        if (openAiWs.readyState === WebSocket.OPEN) {
                            openAiWs.send(JSON.stringify({
                                type: 'input_audio_buffer.append',
                                audio: data.media.payload,
                            }));
                        }
                        break;
                    case 'start':
                        streamSid = data.start.streamSid;
                        console.log('üéôÔ∏è Stream started:', streamSid);
                        if (data.start.customParameters) {
                            firstName = data.start.customParameters.first_name || firstName;
                            address = data.start.customParameters.address || address;
                            console.log(`üìã Call variables ‚Äî Name: ${firstName}, Address: ${address}`);
                        }
                        responseStartTimestampTwilio = null;
                        latestMediaTimestamp = 0;
                        break;
                    case 'mark':
                        if (markQueue.length > 0) markQueue.shift();
                        break;
                    default:
                        if (data.event !== 'media') console.log('üì°', data.event);
                        break;
                }
            } catch (error) {
                console.error('Error parsing Twilio message:', error);
            }
        });

        connection.on('close', () => {
            if (openAiWs.readyState === WebSocket.OPEN) openAiWs.close();
            console.log('üîå Client disconnected.');
        });
        openAiWs.on('close', () => console.log('üîå Disconnected from OpenAI'));
        openAiWs.on('error', (error) => console.error('‚ùå OpenAI error:', error));
    });
});

fastify.listen({ port: PORT }, (err) => {
    if (err) { console.error(err); process.exit(1); }
    console.log(`\nüè† J&J Roofing Voice Agent listening on port ${PORT}`);
    console.log(`üìû Make calls: POST ${SERVER_URL}/make-call`);
    console.log(`üîß Tools: book_meeting (Cal.com)\n`);
});
